<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Sesión 1.3 Programación de red con python. UDP</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f8f8f8; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } /* Alert */
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #c4a000; } /* Attribute */
code span.bn { color: #0000cf; } /* BaseN */
code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4e9a06; } /* Char */
code span.cn { color: #000000; } /* Constant */
code span.co { color: #8f5902; font-style: italic; } /* Comment */
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code span.dt { color: #204a87; } /* DataType */
code span.dv { color: #0000cf; } /* DecVal */
code span.er { color: #a40000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cf; } /* Float */
code span.fu { color: #000000; } /* Function */
code span.im { } /* Import */
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code span.ot { color: #8f5902; } /* Other */
code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code span.sc { color: #000000; } /* SpecialChar */
code span.ss { color: #4e9a06; } /* SpecialString */
code span.st { color: #4e9a06; } /* String */
code span.va { color: #000000; } /* Variable */
code span.vs { color: #4e9a06; } /* VerbatimString */
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style type="text/css">figure {
padding: 1em;
margin: 2em auto;
box-shadow: 10px 10px 7px -5px rgba(0,0,0,0.51);
}
figcaption {
font-size: small;
font-weight: bold;
text-align: center;
margin: 1em;
color: #888;
}
.markdown-body .highlight pre, .markdown-body pre {
padding: 0pt !important;
border-radius: 3px;
}
div.sourceCode {
margin: 0pt;
padding: 0pt;
border-radius: 3px;
margin-bottom: 1em;
}
pre.sourceCode::before {
font-size: 1rem;
color: #fff;
display: block;
position: relative;
top: 0pt;
left: 0pt;
width: 100%;
background: #999;
padding: 0;
text-indent: 1em;
background: #ccc;
padding: 0;
border-top-left-radius: 3px;
border-top-right-radius: 3px;
margin-bottom: 1ex;
}
pre.console, pre.shell {
padding: .5em 1em !important;
}
.markdown-body pre code {
text-indent: 1em;
}
pre.sourceCode.html::before{
content: "HTML";
}
pre.sourceCode.css::before{
content: "CSS";
}
pre.sourceCode.xml::before{
content: "XML";
}
pre.sourceCode.json::before{
content: "JSON";
}
pre.sourceCode.nginx::before{
content: "Nginx config";
}
pre.sourceCode.javascript::before{
content: "Javascript";
background-color: steelblue;
}
pre.sourceCode.text::before{
content: "";
}
pre.sourceCode.yaml::before{
content: "Yaml";
}
pre.sourceCode.sql::before{
content: "SQL";
}
pre.sourceCode.rust::before{
content: "Pseudocódigo";
background-color: #f3e2bb;
color: #c09022;
}
pre.sourceCode.c\+\+::before{
content: "XDR";
background-color: #f3e2bb;
color: #c09022;
}
pre.sourceCode.python::before{
content: "Python";
background-color: #f3e2bb;
color: #c09022;
}
pre.sourceCode.java::before{
content: "Java";
background-color: #f3e2bb;
color: #c09022;
}
pre.sourceCode.C::before{
content: "C";
}
pre.sourceCode.dockerfile::before{
content: "Dockerfile";
}
pre.sourceCode.Makefile::before{
content: "Makefile";
background-color: #d0d0e0;
color: #888;
}
pre.sourceCode.bash::before{
content: "Shell";
background-color: #888;
}
code.sourceCode > span {
display: inline-block;
line-height: 1.4;
min-height: 1.4em;
}
.markdown-body {
-ms-text-size-adjust: 100%;
-webkit-text-size-adjust: 100%;
color: #24292e;
font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
font-size: 16px;
line-height: 1.5;
word-wrap: break-word;
box-sizing: border-box;
min-width: 200px;
max-width: 110ex;
margin: 0 auto;
padding: 45px;
text-align: justify;
}
.markdown-body a {
color: #0366d6;
background-color: transparent;
text-decoration: none;
-webkit-text-decoration-skip: objects
}
.markdown-body a:active,
.markdown-body a:hover {
outline-width: 0
}
.markdown-body a:hover {
text-decoration: underline
}
.markdown-body a:not([href]) {
color: inherit;
text-decoration: none
}
.markdown-body strong {
font-weight: 600
}
.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
margin-top: 24px;
margin-bottom: 16px;
font-weight: 600;
line-height: 1.25
}
.markdown-body h1 {
font-size: 2em;
margin: .67em 0;
padding-bottom: .3em;
border-bottom: 1px solid #eaecef
}
.markdown-body h2 {
padding-bottom: .3em;
font-size: 1.5em;
border-bottom: 1px solid #eaecef
}
.markdown-body h3 {
font-size: 1.25em
}
.markdown-body h4 {
font-size: 1em
}
.markdown-body h5 {
font-size: .875em
}
.markdown-body h6 {
font-size: .85em;
color: #6a737d
}
.markdown-body img {
border-style: none
}
.markdown-body svg:not(:root) {
overflow: hidden
}
.markdown-body hr {
box-sizing: content-box;
height: .25em;
margin: 24px 0;
padding: 0;
overflow: hidden;
background-color: #e1e4e8;
border: 0
}
.markdown-body hr::before {
display: table;
content: ""
}
.markdown-body hr::after {
display: table;
clear: both;
content: ""
}
.markdown-body input {
margin: 0;
overflow: visible;
font: inherit;
font-family: inherit;
font-size: inherit;
line-height: inherit
}
.markdown-body [type=checkbox] {
box-sizing: border-box;
padding: 0
}
.markdown-body * {
box-sizing: border-box
}
.markdown-body blockquote {
margin: 0
}
.markdown-body ol,
.markdown-body ul {
padding-left: 2em
}
.markdown-body ol ol {
list-style-type: lower-roman
}
.markdown-body ol ol,
.markdown-body ol ul,
.markdown-body ul ol,
.markdown-body ul ul {
margin-top: 0;
margin-bottom: 0
}
.markdown-body ol ol ol,
.markdown-body ol ul ol,
.markdown-body ul ol ol,
.markdown-body ul ul ol {
list-style-type: lower-alpha
}
.markdown-body li>p {
margin-top: 16px
}
.markdown-body li+li {
margin-top: .25em
}
.markdown-body dd {
margin-left: 0
}
.markdown-body dl {
padding: 0
}
.markdown-body dl dt {
padding: 0;
margin-top: 16px;
font-size: 1em;
font-style: italic;
font-weight: 600
}
.markdown-body dl dd {
padding: 0 16px;
margin-bottom: 16px
}
.markdown-body code {
font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, Courier, monospace
}
.markdown-body pre {
font: 12px SFMono-Regular, Consolas, "Liberation Mono", Menlo, Courier, monospace;
word-wrap: normal
}
.markdown-body blockquote,
.markdown-body dl,
.markdown-body ol,
.markdown-body p,
.markdown-body pre,
.markdown-body table,
.markdown-body ul {
margin-top: 0;
margin-bottom: 16px
}
.markdown-body blockquote {
padding: 0 1em;
color: #6a737d;
background-color: #eaecef;
border-left: .25em solid #bac6d3
}
.markdown-body blockquote>:first-child {
margin-top: 0
}
.markdown-body blockquote>:last-child {
margin-bottom: 0
}
.markdown-body table {
display: block;
width: 100%;
overflow: auto;
border-spacing: 0;
border-collapse: collapse
}
.markdown-body table th {
font-weight: 600;
background-color: #fff1af;
color: #c66e41;
}
.markdown-body table td,
.markdown-body table th {
padding: 6px 13px;
border: 1px solid #dfe2e5
}
.markdown-body table tr {
background-color: #fff;
border-top: 1px solid #c6cbd1
}
.markdown-body table tr:nth-child(2n) {
background-color: #f6f8fa
}
.markdown-body img {
max-width: 100%;
box-sizing: content-box;
background-color: #fff
}
.markdown-body code {
padding: .2em 0;
margin: 0;
font-size: 85%;
background-color: rgba(27, 31, 35, .10);
word-break: normal;
word-wrap: normal;
border-radius: 3px
}
.markdown-body code::after,
.markdown-body code::before {
letter-spacing: -.2em;
content: "\00a0"
}
.markdown-body pre>code {
padding: 0;
margin: 0;
font-size: 100%;
word-break: normal;
white-space: pre;
background: 0 0;
border: 0
}
.markdown-body .highlight {
margin-bottom: 16px
}
.markdown-body .highlight pre {
margin-bottom: 0;
word-break: normal
}
.markdown-body .highlight pre,
.markdown-body pre {
padding: 16px;
overflow: auto;
font-size: 85%;
line-height: 1.45;
background-color: #f6f8fa;
border-radius: 3px
}
.markdown-body pre code {
display: inline;
max-width: auto;
padding: 0;
margin: 0;
overflow: visible;
line-height: inherit;
word-wrap: normal;
background-color: transparent;
border: 0
}
.markdown-body pre code::after,
.markdown-body pre code::before {
content: normal
}
.markdown-body .full-commit .btn-outline:not(:disabled):hover {
color: #005cc5;
border-color: #005cc5
}
.markdown-body kbd {
box-shadow: inset 0 -1px 0 #959da5;
display: inline-block;
padding: 3px 5px;
font: 11px/10px SFMono-Regular, Consolas, "Liberation Mono", Menlo, Courier, monospace;
color: #444d56;
vertical-align: middle;
background-color: #fcfcfc;
border: 1px solid #c6cbd1;
border-bottom-color: #959da5;
border-radius: 3px;
box-shadow: inset 0 -1px 0 #959da5
}
.markdown-body :checked+.radio-label {
position: relative;
z-index: 1;
border-color: #0366d6
}
.markdown-body .task-list-item {
list-style-type: none
}
.markdown-body .task-list-item+.task-list-item {
margin-top: 3px
}
.markdown-body .task-list-item input {
margin: 0 .2em .25em -1.6em;
vertical-align: middle
}
.markdown-body::before {
display: table;
content: ""
}
.markdown-body::after {
display: table;
clear: both;
content: ""
}
.markdown-body>:first-child {
margin-top: 0 !important
}
.markdown-body>:last-child {
margin-bottom: 0 !important
}
.Alert,
.Error,
.Note,
.Success,
.Warning {
padding: 11px;
margin-bottom: 24px;
border-style: solid;
border-width: 1px;
border-radius: 4px
}
.Alert p,
.Error p,
.Note p,
.Success p,
.Warning p {
margin-top: 0
}
.Alert p:last-child,
.Error p:last-child,
.Note p:last-child,
.Success p:last-child,
.Warning p:last-child {
margin-bottom: 0
}
.Alert {
color: #246;
background-color: #e2eef9;
border-color: #bac6d3
}
.Warning {
color: #4c4a42;
background-color: #fff9ea;
border-color: #dfd8c2
}
.Error {
color: #911;
background-color: #fcdede;
border-color: #d2b2b2
}
.Success {
color: #22662c;
background-color: #e2f9e5;
border-color: #bad3be
}
.Note {
color: #2f363d;
background-color: #f6f8fa;
border-color: #d5d8da
}
.Alert h1,
.Alert h2,
.Alert h3,
.Alert h4,
.Alert h5,
.Alert h6 {
color: #246;
margin-bottom: 0
}
.Warning h1,
.Warning h2,
.Warning h3,
.Warning h4,
.Warning h5,
.Warning h6 {
color: #4c4a42;
margin-bottom: 0
}
.Error h1,
.Error h2,
.Error h3,
.Error h4,
.Error h5,
.Error h6 {
color: #911;
margin-bottom: 0
}
.Success h1,
.Success h2,
.Success h3,
.Success h4,
.Success h5,
.Success h6 {
color: #22662c;
margin-bottom: 0
}
.Note h1,
.Note h2,
.Note h3,
.Note h4,
.Note h5,
.Note h6 {
color: #2f363d;
margin-bottom: 0
}
.Alert h1:first-child,
.Alert h2:first-child,
.Alert h3:first-child,
.Alert h4:first-child,
.Alert h5:first-child,
.Alert h6:first-child,
.Error h1:first-child,
.Error h2:first-child,
.Error h3:first-child,
.Error h4:first-child,
.Error h5:first-child,
.Error h6:first-child,
.Note h1:first-child,
.Note h2:first-child,
.Note h3:first-child,
.Note h4:first-child,
.Note h5:first-child,
.Note h6:first-child,
.Success h1:first-child,
.Success h2:first-child,
.Success h3:first-child,
.Success h4:first-child,
.Success h5:first-child,
.Success h6:first-child,
.Warning h1:first-child,
.Warning h2:first-child,
.Warning h3:first-child,
.Warning h4:first-child,
.Warning h5:first-child,
.Warning h6:first-child {
margin-top: 0
}
h1.title,
p.subtitle,
p.date {
text-align: center
}
h1.title.followed-by-subtitle {
margin-bottom: 0
}
p.subtitle {
font-size: 1.5em;
font-weight: 600;
line-height: 1.25;
margin-top: 0;
margin-bottom: 16px;
padding-bottom: .3em
}
div.line-block {
white-space: pre-line
}
.markdown-body img {
margin: auto;
display: block;
}
.Profe,
.Alumno,
.Cuestion {
padding: 1ex 1em 1ex 4.5em;
margin: 1em 2em 1em 0em;
border-style: solid;
border-width: 1px;
border-radius: 4px;
position: relative;
}
.Profe p,
.Alumno p,
.Cuestion p {
margin-top: 0
}
.Profe p:last-child,
.Alumno p:last-child,
.Cuestion p:last-child {
margin-bottom: 0
}
.Profe {
color: #246;
background-color: #e2eef9;
border-color: #bac6d3
}
.Alumno {
color: #4d2600;
background-color: #ffcc99;
border-color: #ff8000
}
.Cuestion {
color: #4d2600;
background-color: #ffeedc;
border-color: #ffd9b3
}
.Profe::before {
content: "👁";
font-size: 42px;
position: absolute;
top: -5px;
left: 5px;
}
.Alumno::before {
content: "⚙️";
font-size: 42px;
position: absolute;
top: -5px;
left: 5px;
}
.Cuestion::before {
content: "💭";
font-size: 42px;
position: absolute;
top: -5px;
left: 5px;
}
#TOC {
width: 20%;
position: fixed;
z-index: 1;
top: 0px;
left: 0px;
padding: 0px 10px;
height: 100%;
background-color: #f6f8fa;
font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
font-size: 12px;
line-height: 0.8;
overflow-y: auto;
overflow-x: hidden;
}
#TOC a {
text-decoration: none;
color: #3676ab;
}
.toc-title {
color: #999;
}
#main {
margin-left: 20%;
}
#TOC>ul {
margin-left: -2.5em;
}
#TOC>ul>li {
font-size: 18px;
line-height: 27px;
list-style-type: none;
}
#TOC>ul>li>ul>li {
font-size: 16px;
line-height: 24px;
}
#TOC>ul>li>ul>li>ul>li {
font-size: 14px;
line-height: 21px;
}
.markdown-body header {
text-align: center;
margin-bottom: 52pt;
}
@media print {
#TOC {
page-break-after: always;
}
.markdown-body {
text-align: justify;
}
}
@media print, screen and (max-width: 767px) {
.markdown-body {
padding: 2px;
text-align: left;
}
#TOC {
position: inherit;
width: 100%;
height: auto;
page-break: inherit;
}
#main {
margin-left: 0pt;
}
.markdown-body ol,
.markdown-body ul {
padding-left: 1.5em
}
.Profe,
.Alumno,
.Cuestion {
padding: 1ex 1ex 1ex 1em;
margin: 2em 0ex 2ex 2ex;
border-style: solid;
border-width: 1px;
border-radius: 4px;
position: relative;
}
.Profe::before {
content: "👁";
font-size: 32px;
position: absolute;
top: -25px;
left: -20px;
}
.Alumno::before {
content: "⚙️";
font-size: 32px;
position: absolute;
top: -25px;
left: -20px;
}
.Cuestion::before {
content: "💭";
font-size: 32px;
position: absolute;
top: -25px;
left: -20px;
}
}
</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->

</head>
<body>
<div id="wrapper">
<nav id="TOC">
<h1 class="toc-title">Índice</h1>
<ul>
<li><a href="#introducción"><span class="toc-section-number">1</span> Introducción</a></li>
<li><a href="#resumen-de-python-para-programación-de-red"><span class="toc-section-number">2</span> Resumen de python para programación de red</a>
<ul>
<li><a href="#acceso-a-argumentos-de-línea-de-comandos"><span class="toc-section-number">2.1</span> Acceso a argumentos de línea de comandos</a></li>
<li><a href="#api-de-sockets"><span class="toc-section-number">2.2</span> API de sockets</a></li>
<li><a href="#cadenas-o-bytes"><span class="toc-section-number">2.3</span> ¿Cadenas o bytes?</a></li>
</ul></li>
<li><a href="#protocolo-udp"><span class="toc-section-number">3</span> Protocolo UDP</a>
<ul>
<li><a href="#pérdidas-de-paquetes"><span class="toc-section-number">3.1</span> Pérdidas de paquetes</a></li>
<li><a href="#detectar-la-pérdida-de-paquetes"><span class="toc-section-number">3.2</span> Detectar la pérdida de paquetes</a></li>
<li><a href="#reenviar-paquetes-perdidos"><span class="toc-section-number">3.3</span> Reenviar paquetes perdidos</a></li>
<li><a href="#otras-mejoras"><span class="toc-section-number">3.4</span> Otras mejoras</a></li>
</ul></li>
<li><a href="#broadcast-bajo-udp"><span class="toc-section-number">4</span> Broadcast bajo UDP</a>
<ul>
<li><a href="#servidor"><span class="toc-section-number">4.1</span> Servidor</a></li>
<li><a href="#cliente"><span class="toc-section-number">4.2</span> Cliente</a></li>
</ul></li>
<li><a href="#despliegue-con-docker"><span class="toc-section-number">5</span> Despliegue con Docker</a>
<ul>
<li><a href="#instalación-de-docker"><span class="toc-section-number">5.1</span> Instalación de Docker</a></li>
<li><a href="#qué-es-docker"><span class="toc-section-number">5.2</span> ¿Qué es docker?</a></li>
<li><a href="#primer-ejemplo"><span class="toc-section-number">5.3</span> Primer ejemplo</a></li>
<li><a href="#lanzar-el-servidor-udp-en-un-contenedor"><span class="toc-section-number">5.4</span> Lanzar el servidor UDP en un contenedor</a></li>
<li><a href="#lanzar-el-ejemplo-broadcast"><span class="toc-section-number">5.5</span> Lanzar el ejemplo broadcast</a></li>
</ul></li>
</ul>
</nav>
<div id="main">
<article class="markdown-body">
<header>
<h1 class="title followed-by-subtitle">Sesión 1.3 Programación de red con python. UDP</h1>
<p class="subtitle">Ingeniería de Servicios</p>
<p class="date">2023-2024</p>
</header>
<div id="main-text">
<h1 data-number="1" id="introducción" data-number="1"><span class="header-section-number">1</span> Introducción</h1>
<p>Esta práctica se divide en dos sesiones, la primera para UDP y la segunda para TCP, mostrando cómo usar estos protocolos de transporte para transferir datos entre dos procesos (que pueden estar en la misma o en diferentes máquinas), ilustrando los problemas que deben tenerse en cuenta en cada protocolo, junto con sus posibles soluciones. Estos problemas son: pérdidas de datagramas, retransmisiones, reordenación, etc. para el caso UDP, y la delimitación del mensaje (<em>framing</em>) para el caso TCP.</p>
<p>Todos los ejercicios se programarán en Python para simplificar la sintaxis, pero las técnicas aquí utilizadas son válidas para cualquier lenguaje de programación. En particular, el alumno debe estar familiarizado con la API de sockets en C, puesto que los conceptos son los mismos.</p>
<p>Además el despliegue de los servidores se hará con <em>docker</em>, como una forma de presentar esta herramienta que será utilizada más veces en prácticas futuras.</p>
<h1 data-number="2" id="resumen-de-python-para-programación-de-red" data-number="2"><span class="header-section-number">2</span> Resumen de python para programación de red</h1>
<p>Python incluye entre sus bibliotecas estándar la denominada <code>socket</code> que da acceso directo a la API de sockets del operativo, con una sintaxis simplificada pero con los mismos conceptos subyacentes que los que el alumno ya debe conocer de otros lenguajes (especialmente el C). Como veremos, la relación entre la biblioteca de sockets de python y la API C es prácticamente 1 a 1.</p>
<p>En muchos de los ejercicios que realizaremos en este curso necesitaremos pasar argumentos desde línea de comandos al programa que vamos a ejecutar. Por ejemplo, a la hora de lanzar un servidor habitualmente le pasaremos como argumento el número de puerto en que deberá atender peticiones, y a la hora de lanzar un cliente le pasaremos la dirección IP o nombre de la máquina en que se ejecuta el servidor y el número de puerto en que éste está escuchando.</p>
<p>Comenzaremos por tanto por ver cómo es el acceso a estos argumentos de línea de comandos desde el código python.</p>
<h2 data-number="2.1" id="acceso-a-argumentos-de-línea-de-comandos" data-number="2.1"><span class="header-section-number">2.1</span> Acceso a argumentos de línea de comandos</h2>
<p>Para poder acceder a los argumentos es necesario incluir el módulo <code>sys</code>. Este módulo contiene una variable llamada <code>argv</code> que es una lista python de strings, siendo cada uno de los elementos de esta lista el valor de uno de los argumentos pasados al programa por línea de comandos. El concepto (e incluso el nombre) es el mismo que el del parámetro <code>argv</code> de la función <code>main</code> del C, pero con las siguientes diferencias:</p>
<ul>
<li>En python no es un parámetro de ninguna función, sino una variable “global” del módulo <code>sys</code>, por tanto accederemos a ella por el nombre <code>sys.argv</code></li>
<li>En python no existe el parámetro <code>argc</code> típico del C que nos decía cuántos parámetros había recibido el programa. No es necesario este parámetro en python ya que la propia longitud del array anterior nos da este dato. Recordemos que esta longitud se halla con <code>len(sys.argv)</code></li>
</ul>
<h2 data-number="2.2" id="api-de-sockets" data-number="2.2"><span class="header-section-number">2.2</span> API de sockets</h2>
<p>El módulo <code>socket</code> contiene todo lo necesario para acceder a las funciones de manejo de sockets a bajo nivel (a nivel de la API C). Las típicas funciones que ya conoces del lenguaje C tienen su contrapartida en python, pero la sintaxis de algunas de ellas se ha simplificado. Reseñamos las diferencias más importantes:</p>
<ul>
<li><p><code>socket()</code> crea un socket nuevo y lo devuelve como resultado. A diferencia del C, se pueden omitir los parámetros en esta función, y por defecto creará un socket de tipo <code>AF_INET</code>, para el protocolo <code>SOCK_STREAM</code> sobre IPv4 (tercer parámetro 0). En caso de que se quiera un socket UDP, es necesario especificar los dos primeros parámetros (el tercero puede omitirse) como sigue:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> socket</span>
<span id="cb1-2"><a href="#cb1-2"></a>s <span class="op">=</span> socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span></code></pre></div>
<p>El socket devuelto por esta función es un <em>objeto</em> en python (a diferencia del C donde era un entero). La mayoría de las funciones que operan sobre este socket serán métodos de este objeto.</p></li>
<li><p><code>bind()</code> asigna a un socket previamente creado una dirección y un puerto. Las diferencias más importantes con el lenguaje C son:</p>
<ul>
<li>El socket no se pasa como parámetro, sino que <code>bind()</code> es un método del objeto socket.</li>
<li>La dirección y puerto no se pasan en una estructura <code>sockaddr</code>, sino en una tupla de dos elementos, siendo el primero la dirección (un string) y el segundo el puerto (un entero).</li>
<li>La dirección es un string que puede contener una IP (con notación de puntos), o un nombre de una máquina, en cuyo caso la función internamente resolverá el nombre en una IP. Lo más habitual es que queramos especificar como IP la constante especial <code>INADDR_ANY</code>, que en python sería <code>socket.INADDR_ANY</code>, o también la IP <code>&quot;0.0.0.0&quot;</code>, que es exactamente lo mismo, o más sencillo aún, la IP <code>&quot;&quot;</code> (cadena vacía) que python convertirá en la constante anterior.</li>
</ul>
<p>Por tanto, un ejemplo de asignación del puerto 8080 a un socket previamente creado sería:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a>s.bind((<span class="st">&quot;&quot;</span>, <span class="dv">8080</span>))</span></code></pre></div>
<p>Observa que en realidad la función recibe un único parámetro, aunque parecen dos, que es la tupla que contiene IP y puerto. De ahí que aparezcan duplicados los paréntesis.</p></li>
<li><p><code>listen()</code>, aplicable a sockets TCP, convierte el socket en pasivo (para aceptar conexiones). Recibe como parámetro el número máximo de clientes que se mantendrán a la espera de un <code>accept()</code>, los que lleguen después serán rechazados por el operativo.</p></li>
<li><p><code>accept()</code> espera clientes en un socket pasivo TCP. A diferencia de la versión C, en python esta función no recibe parámetros y retorna dos resultados (una tupla). El primero de ellos es un nuevo socket sobre el que se hará la lectura/escritura y el segundo es un par <em>(direccion, puerto)</em> correspondientes al cliente que se acaba de aceptar.</p></li>
<li><p><code>connect()</code> tiene una sintaxis análoga a la de <code>bind()</code> antes explicada.</p></li>
<li><p><code>send()</code>, aplicable a sockets TCP, recibe un único parámetro que es una cadena de bytes de python. No es necesario especificar el socket por el que se envía, ya que en realidad <code>send()</code> es un método de ese objeto socket, ni es necesario especificar el número de bytes a enviar, ya que la longitud de la cadena de bytes proporciona ese dato. Por tanto un ejemplo sería:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a>s.send(b<span class="st">&quot;Este mensaje se envia por el socket&quot;</span>)</span></code></pre></div>
<p>Observa la <code>b</code> delante de las comillas. Esto es sintaxis de Python3 y sirve para identificar la cadena en cuestión como una cadena de bytes, en lugar de una cadena de caracteres Unicode, que sería lo que tendríamos si no hubiéramos puesto la <code>b</code> delante. Sin esa <code>b</code>, tendríamos un error al tratar de enviar caracteres Unicode por un socket, ya que la API de sockets sólo puede enviar bytes. ¿Cuál es la diferencia? Si estamos trabajando con caracteres ASCII, como es el caso del ejemplo anterior, cada uno de los caracteres se codifica en un byte por lo que la cadena de bytes es en realidad la cadena de códicos ASCII de lo que va entre comillas. Sin embargo, si trabajamos con caracteres no ASCII (por ejemplo, acentos o eñes), entonces la codificación de la cadena ya no necesariamente será un byte por letra. Depende de si usamos utf-8, utf-16 u otros <em>encodings</em>.</p>
<p>Al igual que en C, esta función no garantiza el envío de todos los bytes que componen el mensaje, puede que se envíen sólo parte de ellos. La función retorna un entero que indica cuántos ha enviado con éxito. Es responsabilidad del programador chequear ese valor y enviar de nuevo lo que falte. En C esto típicamente se hace mediante un bucle que vaya actualizando el puntero a los datos y el número de bytes que aún faltan por enviar. En python se puede simplificar enormemente la programación haciendo uso de la función <code>socket.sendall()</code>, que no forma parte de la API C, sino que es proporcionada por la biblioteca python. Como su nombre sugiere, esta función asegura que todos los bytes son enviados, para lo cual contiene un bucle como el descrito. El problema es que si la red está congestionada y todos los buffers llenos, la función será bloqueante hasta que todos los datos hayan podido ser enviados.</p></li>
<li><p><code>recv()</code>, aplicable a sockets TCP, recibe como parámetro el número de bytes que se quieren recibir y retorna una cadena de bytes, con los bytes recibidos. Aplicando <code>len()</code> sobre esa cadena podremos saber el número de ellos recibidos. Si retorna una cadena vacía (cuya <code>len()</code> sería cero), sería un indicador de que el otro extremo de la comunicación ha cerrado el socket (un “fin de transmisión”). Si no hay bytes disponibles, la función se bloqueará hasta que los haya.</p></li>
<li><p><code>sendto()</code>, aplicable a sockets UDP recibe dos parámetros. El primero es la cadena de bytes, que contiene los bytes a enviar en el datagrama (como en <code>send()</code>), y el segundo es una tupla de dos elementos <em>(dirección, puerto)</em> como la explicada en <code>connect()</code> o en <code>bind()</code>. Véase el ejemplo del punto siguiente.</p></li>
<li><p><code>recvfrom()</code>, aplicable a sockets UDP, recibe un único parámetro que es un entero especificando el número de bytes máximo esperado en el datagrama. La función retorna una tupla con dos elementos, siendo el primero una cadena de bytes, con los bytes del datagrama recibido, y el segundo una tupla con la <em>(dirección, puerto)</em> del que proviene el datagrama. Cuando una función python retorna una tupla, ésta puede asignarse a dos variables separadas. Así pues, el siguiente ejemplo quedaría esperando a recibir un datagrama y lo mostraría por pantalla además de devolverlo a modo de “eco” a su origen:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a>datagrama, origen <span class="op">=</span> s.revfrom(<span class="dv">1024</span>)  <span class="co"># 1024 es el máximo tamaño esperado</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="bu">print</span>(<span class="st">&quot;Se ha recibido un datagrama desde&quot;</span>, origen)</span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="bu">print</span>(<span class="st">&quot;Contiene lo siguiente:&quot;</span>)</span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="bu">print</span>(datagrama.decode(<span class="st">&quot;utf-8&quot;</span>))</span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="co"># Ahora lo devolvemos a modo de eco</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>s.sendto(datagrama, origen)</span></code></pre></div></li>
</ul>
<h2 data-number="2.3" id="cadenas-o-bytes" data-number="2.3"><span class="header-section-number">2.3</span> ¿Cadenas o bytes?</h2>
<p>Como hemos visto, Python3 tiene dos tipos de cadenas. Las de caracteres, reconocibles por ir entre comilas como <code>&quot;ésta&quot;</code>, y las de bytes, reconocibles por llevar una <code>b</code> delante de las comillas, como <code>b&quot;esta&quot;</code>. Si asignas la primera a una variable, el tipo de la variable será <code>str</code>, mientras que en el segundo caso será <code>bytes</code>.</p>
<p>Las cadenas de caracteres (<code>str</code>) son almacenadas internamente como secuencias de caracteres Unicode y por tanto admiten tildes, eñes y otros alfabetos, y las funciones de formateo, conteo de caracteres, paso a mayúsculas y minúsculas, comparación para ordenación, etc. funcionarán correctamente también con otros alfabetos (incluido el latino).</p>
<p>Las cadenas de <code>bytes</code> son almacenadas internamente como secuencias de bytes sin que Python entre a dar un significado a esos bytes. Son simplemente un vista de una parte de la memoria. Los bytes en cuestión podrían ser parte de una imagen, de un sonido, o también, por qué no, de una cadena de texto ASCII o incluso de la representación en UTF-8 de una cadena unicode. Sin embargo no deben usarse estas cadenas de bytes para almacenar texto no ASCII porque funciones como <code>len()</code> no funcionarían correctamente (retornaría el número de bytes, que no necesariamente coincidirá con el número de caracteres).</p>
<p>Dada una cadena de caracteres, <code>str</code>, es siempre posible convertirlo a una representación de bytes, ya que Unicode a fin de cuentas tiene también una representación binaria. El problema es que la representación binaria de un caracter Unicode depende del <em>encoding</em> elegido. Así el caracter <code>&quot;ñ&quot;</code> tiene diferente representación binaria según se codifique en <code>latin1</code>, <code>cp850</code>, <code>utf8</code>, etc. La función que permite convertir un <code>str</code> en <code>bytes</code> se llama <code>bytes()</code> y recibe como parámetros la cadena a convertir y el nombre del <em>encoding</em> a utilizar. Por ejemplo:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a><span class="op">&gt;&gt;&gt;</span> a <span class="op">=</span> <span class="st">&quot;ñ&quot;</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">bytes</span>(a, <span class="st">&quot;utf8&quot;</span>)</span>
<span id="cb5-3"><a href="#cb5-3"></a>b<span class="st">&#39;</span><span class="ch">\xc3\xb1</span><span class="st">&#39;</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">bytes</span>(a, <span class="st">&quot;latin&quot;</span>)</span>
<span id="cb5-5"><a href="#cb5-5"></a>b<span class="st">&#39;</span><span class="ch">\xf1</span><span class="st">&#39;</span></span></code></pre></div>
<p>Vemos en el ejemplo anterior que la cadena almacenada en la variable <code>a</code> tiene como representación binaria, usando la codificación <code>latin1</code>, un solo byte de valor <code>f1</code>, y sin embargo su representación binaria en <code>utf8</code> requiere dos bytes de valor <code>c3</code>, <code>b1</code>.</p>
<p>Es posible también obtener la representación en <code>bytes</code> de un <code>str</code> a través de su método <code>.encode()</code>. Por ejemplo:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="op">&gt;&gt;&gt;</span> a.encode(<span class="st">&quot;utf8&quot;</span>)</span>
<span id="cb6-2"><a href="#cb6-2"></a>b<span class="st">&#39;</span><span class="ch">\xc3\xb1</span><span class="st">&#39;</span></span></code></pre></div>
<p>La conversión de <code>bytes</code> a <code>str</code> también es posible, pero en general más compleja debido a que necesitamos conocer de antemano qué codificación se usó para obtener la secuencia de bytes, y así poder aplicar la misma para decodificarlo como cadena. Por ejemplo, si tenemos en una variable la secuencia de bytes <code>b&quot;\xc3\xb1&quot;</code> necesitamos saber que está en utf-8 para poder decodificarla y obtener <code>&quot;ñ&quot;</code>, puesto que esa misma secuencia también podría decodificarse bajo <code>latin1</code> dando otro resultado (<code>&quot;Ã±&quot;</code>). La función para hacer esta conversión es <code>str()</code> y recibe como parámetros la cadena de <code>bytes</code> a convertir y el <em>encoding</em> que queremos usar para la decodificación. Por ejemplo:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="op">&gt;&gt;&gt;</span> a <span class="op">=</span> b<span class="st">&quot;</span><span class="ch">\xc3\xb1</span><span class="st">&quot;</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">type</span>(a)</span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="op">&lt;</span><span class="kw">class</span> <span class="st">&#39;bytes&#39;</span><span class="op">&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">str</span>(a, <span class="st">&quot;utf8&quot;</span>)</span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="co">&#39;ñ&#39;</span></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">str</span>(a, <span class="st">&quot;latin1&quot;</span>)</span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="co">&#39;Ã±&#39;</span></span></code></pre></div>
<p>Es posible también obtener la decodificación como <code>str</code> de una variable typo <code>bytes</code> a través de su método <code>.decode()</code>. Por ejemplo:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="op">&gt;&gt;&gt;</span> a.decode(<span class="st">&quot;utf8&quot;</span>)</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="co">&#39;ñ&#39;</span></span></code></pre></div>
<p>Para el manejo de texto las cadenas de tipo <code>str</code> son la norma. Sin embargo cuando es necesario hacer Entrada/Salida (guardar el texto en un fichero o leerlo del mismo, enviarlo o recibirlo por un socket, etc.) será necesario convertirlo en bytes, ya que las APIs de entrada/salida funcionan con bytes. La duda habitual es ¿cuándo hacer esta conversión? Es decir, al leer del fichero a una variable, el resultado será de tipo <code>bytes</code> ¿conviene dejar esta variable con este tipo durante todo el programa y convertirla a Unicode (es decir, al tipo <code>str</code>) sólo cuándo sea necesario tratarlo como cadena? ¿O por el contrario es más conveniente convertirla a Unicode justo tras leerla y ya tratarla como <code>str</code> durante el resto del programa?</p>
<p>La regla general recomendada es la segunda. Es decir, convertir las secuencias de <code>bytes</code> a <code>str</code> tan pronto como son leidas/recibidas y trabajar con ellas todo el rato como <code>str</code>, y convertirlas de nuevo a <code>bytes</code> si han de ser enviadas a un fichero, o por un socket, justo antes de este envío. Dicho de otra forma, trabajar con su forma <code>bytes</code> el menor tiempo posible, y solo en las operaciones de Entrada/Salida, prefiriendo su forma <code>str</code> para todo lo demás.</p>
<p>Naturalmente lo anterior se aplica sólo al caso de que la secuencia de <code>bytes</code> sea en realidad la representación de un texto. Si no representa texto sino otro tipo de información binaria, no tiene sentido (ni será posible en general) convertirlo a una cadena de tipo <code>str</code>, y en este caso se trabajaría todo el rato con su representación de <code>bytes</code>.</p>
<p>Siguiendo esta regla, la forma típica de leer de un socket (asumiendo que lo que leemos es texto codificado en UTF8) sería:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a>texto <span class="op">=</span> s.recv(<span class="dv">50</span>)   <span class="co"># Recibimos 50 bytes (maximo)</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>texto <span class="op">=</span> texto.decode(<span class="st">&quot;utf8&quot;</span>) <span class="co"># Lo pasamos lo antes posible a cadena</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="bu">print</span>(<span class="st">&quot;Texto recibido:&quot;</span>, texto)  <span class="co"># El resto del programa lo trata como cadena</span></span></code></pre></div>
<p>Y la forma típica de enviar un texto por un socket (usando UTF8) sería:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a><span class="co"># La variable texto se ha inicializado de algún modo conteniendo un str</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="co"># Por ejemplo, se ha leido con input()</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>enviados <span class="op">=</span> s.send(texto.encode(<span class="st">&quot;utf8&quot;</span>)) <span class="co"># A la hora de enviarlo lo paso a bytes</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="co"># Cuidado que la variable enviados contendrá el número de bytes enviados</span></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="co"># y no el número de caracteres</span></span></code></pre></div>
<p>Si te das cuenta, el ejemplo de lectura plantea un problema. Ya que hemos limitado a 50 bytes lo leido, ¿qué ocurre si en realidad nos habían enviado más de 50? Recibiríamos sólo los 50 primeros, los cuales quizás no puedan ser correctamente decodificados como UTF8 si ha dado la casualidad de que un caracter multi-byte ha quedado “partido” entre los 50 primeros y los siguientes. Este problema aparece en TCP debido a que el socket es tratado como un “flujo” de datos que puede ser troceado de diferentes formas cuando es leido. En UDP el problema no aparece porque el datagrama es “atómico” (se lee siempre completo, no puede ser partido en dos lecturas). En una futura práctica volveremos al problema con TCP. La práctica actual se dedica a UDP.</p>
<h1 data-number="3" id="protocolo-udp" data-number="3"><span class="header-section-number">3</span> Protocolo UDP</h1>
<p>Bajo UDP la comunicación se reduce a un envío de datagrama con <code>sendto()</code> y la correspondiente recepción con <code>recvfrom()</code>. La capa de transporte hará “todo lo posible” (<em>best effort</em>) porque el datagrama llegue a destino, pero no ofrece garantías. El datagrama es una unidad, o llega completo o se pierde completo. Si el emisor envía varios datagramas, pueden recibirse en diferente orden.</p>
<p>Comencemos con un sencillo ejemplo en que no se tienen en cuenta ninguno de estos problemas.</p>
<div class="Alumno">
<p><strong>Ejercicio 1</strong></p>
<ol type="1">
<li>Escribe un servidor UDP que escuche en el puerto que se le pase por línea de comandos, o en el 9999 por defecto. El servidor estará en un bucle infinito en el que, para cada datagrama que llegue, imprimirá en pantalla el contenido del datagrama y la dirección de la cual proviene. Guárdalo como <code>udp_servidor1.py</code></li>
<li>Escribe un cliente UDP que, en un bucle, lea una línea de texto del teclado y se la envíe en un datagrama al servidor anterior, hasta que la línea leída sea FIN. El cliente recibirá por línea de comandos la IP y puerto del servidor, o asumirá como valores por defecto “localhost” y 9999. Guárdalo como <code>udp_cliente1.py</code></li>
<li>Prueba a ejecutar el servidor en una terminal y el cliente en otra. Prueba también con cliente y servidor en diferentes máquinas (es decir, usa el servidor de tu compañero con tu cliente o viceversa).</li>
</ol>
</div>
<h2 data-number="3.1" id="pérdidas-de-paquetes" data-number="3.1"><span class="header-section-number">3.1</span> Pérdidas de paquetes</h2>
<p>Ya que en una red local es difícil que se pierdan paquetes (imposible además si cliente y servidor están en la misma máquina), tendremos que “simular” que esto ocurra. Para ello:</p>
<div class="Alumno">
<p><strong>Ejercicio 2</strong></p>
<ol type="1">
<li>Modifica el servidor anterior para que, tras recibir el datagrama, decida aleatoriamente con una probabilidad del 50% si simulará no haberlo recibido. En este caso imprimirá en pantalla “Simulando paquete perdido”, en otro caso imprimirá en pantalla el contenido del datagrama tal como hacía antes. Para generar números aleatorios usar el módulo <code>random</code>, por ejemplo la función <code>randint()</code>. Guarda el programa con el nombre <code>udp_servidor2_simula_perdidas.py</code>.</li>
<li>Modifica el cliente para que añada al principio de cada datagrama un número (su representación como string) que vaya incrementándose por cada datagrama enviado. Así, por ejemplo, si el usuario escribe “Hola”, el datagrama enviado será “1: Hola” y el “1” se irá incrementando para sucesivos datagramas. Guarda el programa con el nombre <code>udp_cliente2_numera_mensajes.py</code>.</li>
<li>Ejecutar servidor y cliente y comprobar cómo algunos de los datagramas se pierden y por tanto la secuencia de números tiene saltos. En caso de que cliente y servidor estuvieran separados por muchos nodos intermedios podría incluso observarse que algunos de los números llegan fuera de orden.</li>
</ol>
</div>
<h2 data-number="3.2" id="detectar-la-pérdida-de-paquetes" data-number="3.2"><span class="header-section-number">3.2</span> Detectar la pérdida de paquetes</h2>
<p>Como vemos, el cliente no sabe nunca realmente si el paquete ha llegado o no a destino. De hecho ¡el cliente funciona exactamente igual incluso si el servidor no está corriendo! Una forma de mejorar ésto sería que el servidor respondiera con otro datagrama de “reconocimiento”.</p>
<div class="Alumno">
<p><strong>Ejercicio 3</strong></p>
<p>Modifica el servidor anterior para que, en caso de que decida no perder el paquete, además de mostrarlo por pantalla envíe al cliente otro datagrama conteniendo el texto “OK”. Guárdalo con el nombre <code>udp_servidor3_con_ok.py</code>.</p>
</div>
<p>Lo siguiente sería modificar el cliente para que, tras enviar un datagrama, haga un <code>recvfrom()</code> para recibir el “OK” del servidor. Pero ¿y si el datagrama del cliente se había perdido? No habrá entonces ningún “OK” para recibir y el cliente quedará bloqueado en el <code>recvfrom()</code> a la espera de un “OK” que nunca llegará. Y lo mismo puede ocurrir también (aunque no en esta práctica debido a que estamos en modo local) si el datagrama con el “OK” del servidor se perdiera.</p>
<p>Es necesario incluir un <em>timeout</em> en el cliente, de modo que si transcurrido un tiempo razonable no se ha recibido el “OK” se pueda asumir que estamos ante un error de red.</p>
<h3 data-number="3.2.1" id="incluir-timeouts-en-las-recepciones-de-datos" data-number="3.2.1"><span class="header-section-number">3.2.1</span> Incluir <em>timeouts</em> en las recepciones de datos</h3>
<p>Básicamente se trata de llamar a la función <code>settimeout()</code> del objeto socket pasándole el número de segundos máximo a esperar (puede ser un número fraccionario), antes de invocar <code>recvfrom()</code>. En ese caso la llamada a <code>recvfrom()</code> se bloqueará hasta recibir un datagrama o hasta que expire el <em>timeout</em>, lo que ocurra antes. Si recibe el datagrama retornará en la forma habitual. Si expira el <em>timeout</em> generará una excepción llamada <code>socket.timeout</code>. Capturando esta excepción podemos tomar control sobre el error.</p>
<p>En python las excepciones se tratan poniendo el código que podría generarlas dentro de una clausula <code>try</code>, y seguidamente el código que maneja las excepciones en una cláusula <code>except</code>, como muestra el código siguiente.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a><span class="co"># Ejemplo de recepción de un datagrama con un timeout máximo de una décima de segundo</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="co"># Se supone inicializada la variable s con una llamada a socket</span></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="co"># y que ya se ha enviado un datagrama y se está esperando la respuesta &quot;OK&quot;</span></span>
<span id="cb11-4"><a href="#cb11-4"></a></span>
<span id="cb11-5"><a href="#cb11-5"></a>s.settimeout(<span class="fl">0.1</span>)</span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="cf">try</span>:</span>
<span id="cb11-7"><a href="#cb11-7"></a>    datagrama, origen <span class="op">=</span> s.recvfrom(<span class="dv">1024</span>) <span class="co"># Tamaño máximo a recibir</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>    datagrama <span class="op">=</span> datagrama.decode(<span class="st">&quot;utf8&quot;</span>)</span>
<span id="cb11-9"><a href="#cb11-9"></a>    <span class="cf">if</span> datagrama<span class="op">==</span><span class="st">&quot;OK&quot;</span>:</span>
<span id="cb11-10"><a href="#cb11-10"></a>       <span class="bu">print</span>(<span class="st">&quot;Recibida confirmación&quot;</span>)</span>
<span id="cb11-11"><a href="#cb11-11"></a>    <span class="cf">else</span>:</span>
<span id="cb11-12"><a href="#cb11-12"></a>       <span class="bu">print</span>(<span class="st">&quot;Recibido datagrama no esperado&quot;</span>)</span>
<span id="cb11-13"><a href="#cb11-13"></a><span class="cf">except</span> socket.timeout:</span>
<span id="cb11-14"><a href="#cb11-14"></a>    <span class="bu">print</span>(<span class="st">&quot;ERROR. El datagrama de confirmación no llega&quot;</span>)</span>
<span id="cb11-15"><a href="#cb11-15"></a><span class="cf">except</span>:    <span class="co"># Otras posibles excepciones dejamos que las maneje el usuario</span></span>
<span id="cb11-16"><a href="#cb11-16"></a>    <span class="cf">raise</span></span></code></pre></div>
<div class="Alumno">
<p><strong>Ejercicio 3 (continuación)</strong></p>
<p>Modifica el cliente y guárdalo con el nombre <code>udp_cliente3_espera_ok.py</code> para que tras cada datagrama enviado espere la confirmación, pero limitando el tiempo de espera como se mostró en el código anterior.</p>
<p>Ejecuta los nuevos cliente y servidor y comprueba cómo cuando el servidor “decide” simular la pérdida de un paquete, el cliente detecta correctamente la no recepción del datagrama.</p>
</div>
<h2 data-number="3.3" id="reenviar-paquetes-perdidos" data-number="3.3"><span class="header-section-number">3.3</span> Reenviar paquetes perdidos</h2>
<p>El cliente no debería limitarse a detectar el error, sino que debería hacer algo por resolverlo. El enfoque típico consiste en reenviar el paquete cuya confirmación no se había recibido, aumentando el <em>timeout</em> entre reintentos. Si el <em>timeout</em> alcanza un cierto valor que consideramos inadmisible, el cliente podrá asumir que el servidor está caído y abandonar ya los reintentos.</p>
<div class="Alumno">
<p><strong>Ejercicio 4</strong></p>
<p>Modifica el cliente anterior y guárdalo como <code>udp_cliente4_reintenta.py</code> de modo que en caso de agotar el tiempo de espera (<em>timeout</em>), el cliente repita el envío, duplicando en cada reenvío el valor del <em>timeout</em> hasta que, bien se reciba el “OK”, bien el <em>timeout</em> exceda el valor de 2 segundos. En el primer caso volverá a pedir datos al usuario para volver a enviarlos al servidor, usando el mismo esquema. En el segundo caso imprimirá un mensaje “Puede que el servidor esté caído. Inténtelo más tarde” y finalizará su ejecución. Observa que en los reintentos el número de secuencia del datagrama no se debe incrementar.</p>
<p>Ejecuta el cliente anterior junto con el servidor anterior, <code>udp_servidor3_con_ok.py</code> y comprueba que funcione.</p>
<p>Ejecuta el cliente usando como IP y puerto unas en las que no haya ningún servidor escuchando. Comprueba cómo detecta correctamente el problema (tras varios reintentos) y termina su ejecución.</p>
</div>
<h2 data-number="3.4" id="otras-mejoras" data-number="3.4"><span class="header-section-number">3.4</span> Otras mejoras</h2>
<p>El protocolo anterior no es muy robusto. En primer lugar el datagrama de confirmación contiene meramente “OK” y ninguna indicación de cuál es el datagrama que está confirmando. Si tenemos en cuenta que los datagramas pueden llegar al servidor desordenados, cuando el cliente recibe un “OK” no tiene forma de saber a cuál de los datagramas que envió previamente corresponde esta confirmación.</p>
<p>Además, imagina que el cliente envía un primer datagrama (datagrama 1), la confirmación tarda demasiado en llegar y decide reenviarlo. Recibe un “OK” y a continuación envía un segundo datagrama (datagrama 2), para el que recibe inmediatamente otro “OK”. Parece que ambos datagramas llegaron a destino (el 1 tras un reintento). Pero en realidad pudo ocurrir otra cosa muy diferente. Quizás cuando se envió el datagrama 1 la red iba más lenta por lo que tardó en llegar a destino, pero llegó finalmente, y el servidor confirmó con un “OK”. Poco después llega el reenvío del datagrama 1 que el servidor confirma con otro “OK”. El datagrama 2 en cambio se pierde. La situación por tanto es que el datagrama 1 llegó dos veces (y se confirmó dos veces), mientras que el datagrama 2 se perdió, y sin embargo el cliente “cree” que ambos llegaron (y una sola vez cada uno).</p>
<p>Estos problemas se pueden aliviar incluyendo en cada datagrama algún tipo de identificador, que sea diferente para cada datagrama, pero el mismo para los reenvíos, y usando en el mensaje de confirmación el identificador del datagrama que está siendo confirmado. El número de secuencia de los ejemplos anteriores podría servir como identificador, pero en general es preferible usar identificadores más difíciles de adivinar. Un número aleatorio o un hash criptográfico serían más apropiados.</p>
<p>Por otro lado, este servidor es muy simple y se limita a mostrar en pantalla los datagramas recibidos, sin realizar ningún tipo de procesamiento. En un caso real el servidor tendrá que realizar alguna acción con los datagramas recibidos. Se corre entonces el riesgo de repetir la acción debido a la recepción de duplicados. Por ejemplo, el cliente envía un primer datagrama que llega correctamente a destino y causa que el servidor ejecute alguna acción. Pero el datagrama con la confirmación se pierde, por lo que el cliente, tras agotar su <em>timeout</em> reenvía el mismo datagrama. Cuando éste llegue por segunda vez causará que la acción desencadenada por el primero se repita. En algunos casos esto puede no ser admisible.</p>
<p>Este segundo problema se solventa haciendo que el servidor mantenga una lista de qué identificadores de datagrama ha recibido, y cuando reciba otro con el mismo identificador se limitará a reenviar la confirmación, pero sin ejecutar de nuevo la acción asociada.</p>
<p>Finalmente, cuando el cliente está esperando la confirmación lo hace llamando a <code>recvfrom()</code>, lo cual en principio le abre a recibir cualquier datagrama de cualquier otro proceso, no necesariamente del servidor con quien estaba comunicándose. Por ejemplo, un cliente malicioso podría enviar a nuestro cliente un datagrama con un “OK” para confundirle. El cliente debería comprobar que la IP de origen del datagrama de confirmación es la que debe ser (dejando de lado ataques más complejos como <em>IP spoofing</em>). Una forma más simple de hacer lo mismo es usar en el cliente la función <code>connect()</code> y seguidamente usar <code>recv()</code> para recibir los datagramas. Estas funciones típicamente se asocian a TCP para establecer un canal y leer de él, pero también es posible usarlas en UDP si bien tienen otro significado. En UDP <code>connect()</code> simplemente “declara” la IP y puerto de la que esperamos recibir datagramas (serían las del servidor), pero no inicia ninguna actividad de red ni crea ningún tipo de conexión. Seguidamente <code>recv()</code> funcionará como <code>recvfrom()</code>, pero descartando automáticamente todos los datagramas que no vengan de la IP y puerto especificados previamente en <code>connect()</code>.</p>
<div class="Alumno">
<p><strong>Ejercicio 5 (opcional)</strong></p>
<p>Implementa al menos una de las mejoras propuestas en este apartado. Llama a los ficheros <code>udp_servidor5_mejorado.py</code> y <code>udp_cliente5_mejorado.py</code>.</p>
</div>
<h1 data-number="4" id="broadcast-bajo-udp" data-number="4"><span class="header-section-number">4</span> Broadcast bajo UDP</h1>
<p>UDP soporta <em>broadcast</em>. Esta es la capacidad de enviar un datagrama no a un nodo concreto, sino a <em>todos</em> los nodos conectados a una subred. Esto es útil para implementar clientes que se autoconfiguran, descubriendo por sí mismos cuál es la IP de los servidores que implementan los servicios deseados. Por ejemplo, el protocolo DHCP para obtener la configuración de red utiliza esta técnica.</p>
<p>Para ejemplificar estas ideas inventamos un simple protocolo que llamaremos “HOLA”. Este protocolo consiste simplemente en esperar en un puerto prefijado por un datagrama que diga “HOLA” y responderle al cliente con otro datagrama que diga “HOLA: IP” donde “IP” es la IP de ese cliente.</p>
<p>El cliente desconoce inicialmente la IP del servidor, y usará la técnica del broadcast para que lo descubra. Para ello el cliente enviará por broadcast a todas las máquinas de la subred un datagrama que contenga el texto “BUSCANDO HOLA” al puerto prefijado, y esperará respuestas de posibles servidores. Mostrará en pantalla las IPs de los servidores que han respondido y tomará la primera de ellas para probar el servicio.</p>
<p>Seguidamente damos más detalles de cómo implementar tanto el servidor como el cliente.</p>
<h2 data-number="4.1" id="servidor" data-number="4.1"><span class="header-section-number">4.1</span> Servidor</h2>
<p>Crea un socket UDP en un puerto predeterminado que será el 12345 y espera a recibir datagramas en él. El socket debe estar en “modo broadcast” para que pueda recibir datagramas dirigidos a la subred en que se halla. Para cada datagrama que reciba examinará su contenido para ver si está en uno de los siguientes casos:</p>
<ul>
<li><p>Si el datagrama contiene el texto “BUSCANDO HOLA” responderá al cliente en cuestión con otro datagrama conteniendo “IMPLEMENTO HOLA”, para notificarle que éste servidor implementa ese servicio. Cuando el cliente reciba este datagrama podrá saber la IP del servidor, ya que esta llegará también como parte de <code>recvfrom()</code>.</p></li>
<li><p>Si el datagrama contiene simplemente “HOLA”, responde al cliente con otro que contiene “HOLA: IP” siendo “IP” la del cliente a quien envía el datagrama, es decir, da el servicio en cuestión.</p></li>
</ul>
<p>Para poner un socket en “modo <em>broadcast</em>” es necesario utilizar la función <code>setsockopt()</code>. Esta es una función de la API estándar de sockets en C, y su sintaxis y funcionalidad puede consultarse en la correspondiente <a href="http://www.manpagez.com/man/2/setsockopt/">página de manual</a>, si bien se trata de una función muy versátil que puede realizar un gran número de operaciones según el protocolo y las opciones que se le pasen. Nos centraremos únicamente en su uso para pasar un socket UDP a “modo <em>broadcast</em>”. Para este caso particular, el parámetro <code>level</code> debe contener la constante especial <code>SOL_SOCKET</code>, el parámetro <code>option_name</code> la constante especial <code>SO_BROADCAST</code> y el valor de la opción igual a 1 (activar). La sintaxis de la función en C exige que el valor final (el 1) se pase por referencia, junto con un parámetro extra indicando la longitud en bytes de ese valor.</p>
<p>La versión python simplifica la sintaxis, y en este caso se usaría así:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a><span class="co"># Asumiendo que s es un socket previamente creado para UDP</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, <span class="dv">1</span>)</span></code></pre></div>
<p>Una vez el socket está en “modo <em>broadcast</em>” su uso es idéntico al que ya conocemos. Usando <code>s.recvfrom()</code> se recibirán datagramas en el mismo (con la particularidad de que se reciben también los de tipo <em>broadcast</em>), y usando <code>s.sendto()</code> se pueden enviar respuestas a nodos y puertos concretos.</p>
<h2 data-number="4.2" id="cliente" data-number="4.2"><span class="header-section-number">4.2</span> Cliente</h2>
<p>El cliente crea un socket UDP y da los siguientes pasos:</p>
<ol type="1">
<li>Envía un datagrama por broadcast que contenga el mensaje “BUSCANDO HOLA” al puerto 12345 de todos los nodos de la subred.</li>
<li>Entra en un bucle “infinito” en el que repetidamente llama a <code>recvfrom()</code> para recibir posibles respuestas de servidores. Ya que no sabemos de antemano cuántas podríamos recibir (no sabemos cuántos servidores habrá activos en la subred para este servicio), la mejor estrategia es fijar un <em>timeout</em> para este <code>recvfrom()</code>. Cuando expire el <em>timeout</em> se asume que ya no hay más servidores, y se sale del bucle “infinito”.</li>
<li>Para cada respuesta recibida, se muestra en pantalla la IP del servidor que ha respondido (como ya sabemos <code>recvfrom()</code> retorna también la dirección origen del datagrama, por lo que podemos obtenerla ahí). Además, almacena en una variable la IP del primero que responda.</li>
<li>Si ha respondido al menos un servidor, probamos con él el servicio, enviando a ese servidor concreto (ya no por <em>broadcast</em>, sino a su IP concreta) un datagrama que contenga “HOLA”, y esperamos el datagrama de repuesta que mostramos por pantalla para finalizar.</li>
</ol>
<p>Observa que el paso 4 podría incluir también <em>timeouts</em> y reintentos para tener en cuenta la posible pérdida de paquetes, pero no tendremos en cuenta este problema para simplificar la solución.</p>
<p>Para enviar un datagrama por broadcast a toda una subred se hace en la forma siguiente:</p>
<ul>
<li><p>El socket debe tener activado el modo broadcast, lo cual se hace con <code>setsockopt()</code> (véase el apartado sobre el servidor)</p></li>
<li><p>El datagrama se envía a una IP especial que representa la subred. Esta dirección es la misma que la IP del cliente pero poniendo a 1 los bits que no son parte de la máscara de red. Por ejemplo, si nuestra IP es <code>192.168.0.17</code> y la máscara de red es <code>255.255.255.0</code>, la dirección de <em>broadcast</em> será <code>192.168.0.255</code>.</p>
<p>En Linux puedes averiguar cuál es la dirección de <em>broadcast</em> usando la utilidad <code>ifconfig</code> (aparece en la segunda línea, con el nombre “Difus.”, por <em>difusión</em> que es la traducción de <em>broadcast</em>).</p>
<p>En Windows la utilidad <code>ipconfig</code> permite averiguar esta información, aunque de forma indirecta, a través de la “máscara de subred”.</p></li>
</ul>
<div class="Alumno">
<p><strong>Ejercicio 6</strong></p>
<p>Implementa el servidor y el cliente descritos en los apartados anteriores, dándoles los nombres <code>udp_servidor6_broadcast.py</code> y <code>udp_cliente6_broadcast.py</code>, respectivamente.</p>
<p>Prueba el cliente cuando haya varios servidores funcionando (de otros compañeros) y comprueba cómo recibe varias respuestas.</p>
</div>
<h1 data-number="5" id="despliegue-con-docker" data-number="5"><span class="header-section-number">5</span> Despliegue con Docker</h1>
<h2 data-number="5.1" id="instalación-de-docker" data-number="5.1"><span class="header-section-number">5.1</span> Instalación de Docker</h2>
<p>Docker debe estar ya instalado desde la práctica inicial en que se creó la máquina virtual. Compruébalo con <code>docker version</code>. Si no lo tienes instalado consulta el guión de aquella práctica para instrucciones.</p>
<h2 data-number="5.2" id="qué-es-docker" data-number="5.2"><span class="header-section-number">5.2</span> ¿Qué es docker?</h2>
<p>Docker es un conjunto de herramientas que simplifican enormemente el uso de los <em>contenedores linux</em> (una característica que tiene este operativo, ya desde hace tiempo y de forma independiente de docker).</p>
<p>Un contenedor puede ser conceptualizado como una especie de “mini máquina virtual”. En realidad la tecnología por debajo es completamente diferente. En una máquina virtual se usan instrucciones específicas de virtualización del procesador y es necesario un hipervisor que gestione todo esto. La máquina virtual no tiene un operativo de por sí, y es necesario instalarle uno (como por ejemplo hemos hecho para instalar Ubuntu en VirtualBox). En los contenedores en cambio no es necesario ningún hipervisor, no se instala ningún operativo en ellos, sino que usan llamadas al operativo bajo el cual están corriendo (linux en nuestro caso). Un contenedor es un conjunto de procesos Linux, pero ejecutados de tal forma (haciendo uso de <em>namespaces</em> linux) que no pueden ver nada fuera de su <em>sandbox</em>.</p>
<p>Al margen de los detalles de cómo están implementados, la forma más simple de razonar sobre ellos es imaginar que son equivalentes a una máquina virtual, sólo que mucho más ligera, más rápida de lanzar (no tiene un operativo que arrancar) y que consume menos recursos, sobre todo de disco y memoria (no tiene un disco virtual reservado para ella, no tiene una cantidad de RAM asignada que se quita del anfitrión). En general, correr decenas de contenedores en un Linux es perfectamente posible.</p>
<p>Un concepto importante en Docker es el de <strong>imagen</strong>. Cuando un contenedor es lanzado, no tiene en principio acceso al sistema de archivos, sino que tiene su propio sistema de archivos interno. Por tanto tampoco podrá acceder a las herramientas instaladas en el anfitrión (por ejemplo <code>bash</code>, <code>python</code>, etc.), sino sólo a las que estén accesibles en su propio sistema de archivos privado.</p>
<p>Una imagen es una plantilla (como si fuera una <em>clase</em> en POO), a partir de la cual se <em>instancia</em> (como si fuera un objeto en POO) el contenedor. La imagen proporciona un sistema de archivos con los ejecutables y herramientas que el contenedor podrá usar durante su funcionamiento.</p>
<p>Las imágenes son de sólo lectura. Cuando el contenedor arranca, tendrá visibles en su propio sistema de ficheros (que comienza en la carpeta raíz <code>/</code>, pero que es indpendiente de lo que haya en esa carpeta en el anfitrión). Puede leer de ese sistema de archivos (para cargar programas, datos, etc.) pero si intenta escribir algo, se creará una nueva “capa” en el sistema de archivos y será en esa capa extra donde se realizan las modificaciones. Conceptualmente es similar a un sistema de capas como el que tienen los programas de edición gráfica tipo Photoshop. Cada capa tiene zonas “transparentes” a través de las cuales son visibles las capas inferiores. En el caso de docker eso significa que cuando un proceso dentro del contenedor intenta acceder a un fichero, se busca el mismo en la capa superior y si no está, se sigue buscando en capas inferiores. Sólo la capa superior se puede escribir.</p>
<p>Cuando el contenedor termina su ejecución, típicamente la capa superior en la que ha escrito cosas se descarta (aunque podría guardarse como ya veremos). La consecuencia es que se pierde todo lo que el contenedor haya escrito, y la ventaja es que instanciar un nuevo contenedor nos garantiza que comienza otra vez “de cero”, de la misma imagen, que no pudo ser modificada por otras ejecuciones anteriores.</p>
<p>Además de tener su propio sistema de archivos independiente del del anfitrión, un contenedor también tiene su propia <strong>red</strong>, con su IP y los puertos que estén usando las aplicaciones que corren dentro del contenedor. Esto implica que podemos lanzar la misma aplicación varias veces en diferentes contenedores, sin tener que cambiar el puerto en que escucha cada una, pues cada contenedor es una IP diferente y por tanto no hay choque de puertos.</p>
<h2 data-number="5.3" id="primer-ejemplo" data-number="5.3"><span class="header-section-number">5.3</span> Primer ejemplo</h2>
<p>Para lanzar un contenedor el comando es <code>docker run</code>, y a él hay que pasarle el nombre de la imagen que queremos lanzar. Más adelante crearemos nuestras propias imágenes, pero docker puede usar también un <strong>repositorio público</strong> de imágenes al cual accederá si la imagen que le pedimos lanzar no la encuentra en el repositorio local.</p>
<p>Veamos qué imágenes tenemos instaladas:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1"></a>$ <span class="ex">docker</span> images</span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="ex">REPOSITORY</span>          TAG                 IMAGE ID            CREATED             SIZE</span></code></pre></div>
<p>Por la respuesta vemos que no tenemos ninguna imagen descargada. Descarguemos una que contenga la última versión de python, recientemente aparecida y que aún no está disponible en Ubuntu. Se trata de python 3.7:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1"></a>$ <span class="ex">docker</span> pull python:3.7</span>
<span id="cb14-2"><a href="#cb14-2"></a>[<span class="ex">...</span> descarga varias capas de imágenes, tarda un rato ...]</span>
<span id="cb14-3"><a href="#cb14-3"></a>$ <span class="ex">docker</span> images</span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="ex">REPOSITORY</span>          TAG                 IMAGE ID            CREATED             SIZE</span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="ex">python</span>              3.7                 638817465c7d        8 days ago          922MB</span></code></pre></div>
<p>¿Qué ha ocurrido? Docker se ha conectado con su repositorio, ha encontrado la imagen llamada <code>python</code> con el tag <code>3.7</code> y la ha descargado. La imagen se compone de varias capas, en la primera por ejemplo típicamente están herramientas de línea de comandos típicas de Ubuntu, sobre ellas se instalan herramientas de desarrollo, compiladores C (por si hacen falta en python), etc. Finalmente se instala python y sus bibliotecas. El hacerlo por capas favorece la reutilización. Si, por ejemplo, queremos ahora la versión 3.6, verás que muchas de las capas necesarias ya han sido descargadas por tanto no sólo se acelera la descarga en este segundo caso, sino que además se reduce el uso del disco en el anfitrión:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1"></a>$ <span class="ex">docker</span> pull python:3.6</span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="bu">[</span> ... muchas de las capas necesarias ya estaban descargdas, es más rápido ...]</span>
<span id="cb15-3"><a href="#cb15-3"></a>$ docker images</span>
<span id="cb15-4"><a href="#cb15-4"></a>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span>
<span id="cb15-5"><a href="#cb15-5"></a>python              3.6                 d49c41b6e6c4        8 days ago          918MB</span>
<span id="cb15-6"><a href="#cb15-6"></a>python              3.7                 638817465c7d        8 days ago          922MB</span></code></pre></div>
<p>Tenemos dos imágenes, y aunque se nos reporta que el tamaño de cada una es de unos 900MB, esto no implica que estemos ocupando 1800MB en total, ya que las imágenes tienen grandes partes en común.</p>
<p>Lancemos el contenedor para probar. La forma de lanzarlo es <code>docker run &lt;nombre de la imagen&gt;</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1"></a>$ <span class="ex">docker</span> run python:3.7</span></code></pre></div>
<p>No ha pasado nada? Veamos si tenemos contenedores en ejecución:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1"></a>$ <span class="ex">docker</span> ps</span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="ex">CONTAINER</span> ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span></code></pre></div>
<p>La lista está vacía. No hay contenedores en ejecución. Pero probemos la opción <code>-a</code> (<em>all</em>) que nos muestra también los contenedores que han muerto:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1"></a>$ <span class="ex">docker</span> ps -a </span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="ex">CONTAINER</span> ID        IMAGE               COMMAND             CREATED              STATUS                          PORTS               NAMES</span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="ex">66c93f7b909e</span>        python:3.7          <span class="st">&quot;python3&quot;</span>           About a minute ago   Exited (0) <span class="ex">About</span> a minute ago                       clever_mclean</span></code></pre></div>
<p>Ajá. Aquí vemos el contenedor que acabábamos de lanzar. Podemos ver su ID (que es un hash), que podemos usar para referirnos a él, la imagen desde la que ha sido instanciado (<code>python:3.7</code>) y el comando que ejecutó (<code>python3</code>). El nombre <code>clever_mclean</code>, que en tu caso será diferente, es un nombre aleatorio que docker le pone al contenedor, para que sea más fácil de recordar y teclear que su ID hexadecimal. También podríamos haber especificado nosotros otro nombre con la opción <code>-n</code>.</p>
<p>Entonces el contenedor se ejecutó, lanzó dentro el comando <code>python3</code>, y cuando este comando terminó, el contenedor se terminó. Sigue estando disponible en la lista de <code>docker ps -a</code> por si quisiéramos guardar los cambios que ese contenedor haya podido hacer en la capa de escritura. Si queremos descartar esos posibles cambios, hay que borrar el contenedor con:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1"></a>$ <span class="ex">docker</span> rm clever_mclean <span class="co"># Usa el nombre de tu contenedor</span></span>
<span id="cb19-2"><a href="#cb19-2"></a>$ <span class="ex">docker</span> ps -a</span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="ex">CONTAINER</span> ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span></code></pre></div>
<p>De momento no parece muy útil, pues aunque hemos ejecutado python3 dentro del contenedor, no hemos podido pasarle un archivo <code>.py</code> para que lo ejecute.</p>
<p>Escribe lo siguiente en un fichero llamado <code>prueba.py</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1"></a><span class="im">import</span> sys</span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="bu">print</span>(<span class="st">&quot;Me estoy ejecutando con Python&quot;</span>, sys.version)</span></code></pre></div>
<p>Prueba a ejecutarlo, sin contenedores, con el python que tienes instalado en Ubuntu:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb21-1"><a href="#cb21-1"></a>$ <span class="ex">python3</span> prueba.py</span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="ex">Me</span> estoy ejecutando con Python 3.6.5 (default, Apr  1 2018, 05:46:30)</span>
<span id="cb21-3"><a href="#cb21-3"></a>[<span class="ex">GCC</span> 7.3.0]</span></code></pre></div>
<p>Podemos ver la versión 3.6.5. Ahora probemos a ejecutarlo con la versión 3.7 vía docker:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb22-1"><a href="#cb22-1"></a>$ <span class="ex">docker</span> run python:3.7 python prueba.py</span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="kw">(</span><span class="ex">null</span><span class="kw">)</span><span class="bu">:</span> can<span class="st">&#39;t open file &#39;</span>prueba.py<span class="st">&#39;: [Errno 2] No such file or directory</span></span></code></pre></div>
<p>No ha funcionado. ¿Qué ha ocurrido? Como explicamos en la introducción, el contenedor tiene su propio sistema de ficheros y no puede ver el del anfitrión, por lo que <code>prueba.py</code> no está disponible.</p>
<p>Así las cosas no parece muy útil. ¿Cómo hacer visible <code>prueba.py</code> para el contenedor? Tenemos dos enfoques:</p>
<ol type="1">
<li>Crear una imagen nueva que incluya <code>prueba.py</code>. Esta sería la opción correcta si queremos distribuir nuestro software vía docker. Crearíamos esta imagen (para lo que es necesario escribir un <code>Dockerfile</code>) le daríamos un nombre, y una vez creada podremos subirla al repositorio público de Docker (habría que abrir una cuenta gratuíta). Una vez allí cualquier otra persona con conexión a internet podría hacer <code>docker pull &lt;nombre de nuestra imagen&gt;</code> y obtener una copia local para lanzarla con <code>docker run</code>.</li>
<li>Durante el desarrollo todo lo anterior es demasiada complicación. Lo que suele hacerse en cambio es “montar” la carpeta del anfitrión donde está el archivo que queremos acceder, en una carpeta dentro del contenedor.</li>
</ol>
<p>Veamos la segunda opción. Pasándole a <code>docker run</code> la opción <code>-v /ruta/a/carpeta/local:/ruta/a/carpeta/en/contenedor</code> tendríamos que, una vez dentro del contenedor, los contenidos de la carpeta <code>/ruta/a/carpeta/en/contenedor</code> serían los de la carpeta <code>/ruta/a/carpeta/local/</code> del anfitrión. De hecho no es una mera copia, <em>es la misma carpeta</em>. Si el contenedor escribe algo o borra ficheros, estos cambios sucederán también en la carpeta del anftrión. Por tanto es una buena opción para compartir información entre el anfitrión y el contenedor y viceversa, pero debemos confiar en lo que se esté ejecutando en el contenedor. De todas formas, lo que el contenedor pueda hacer sobre el sistema de archivos del anfitrión está limitado a esa carpeta solamente.</p>
<p>Así pues, podemos usar <code>$(pwd)</code> para obtener cuál es la carpeta actual, y montarla en la ruta <code>/app</code>, por ejemplo, del contenedor, con lo que haríamos:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb23-1"><a href="#cb23-1"></a>$ <span class="ex">docker</span> run -v <span class="va">$(</span><span class="bu">pwd</span><span class="va">)</span>:/app python:3.7 python /app/prueba.py</span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="ex">Me</span> estoy ejecutando con Python 3.7.0 (default, Jul 17 2018, 11:04:33)</span>
<span id="cb23-3"><a href="#cb23-3"></a>[<span class="ex">GCC</span> 6.3.0 20170516]</span></code></pre></div>
<p>Vemos que ha funcionado, y podemos verificar que la versión que lo está ejecutando es la del contenedor, pues es la <code>3.7.0</code>.</p>
<div class="Cuestion">
<p>Prueba a lanzar el mismo programa con la imagen docker <code>python:3.6</code> ¿Usa la misma versión de python que el <code>python3</code> que tienes instalado en Ubuntu?</p>
</div>
<p>Para terminar con el experimento, puede resultarte útil saber que puedes lanzar cualquier otro de los comandos contenidos en la imagen (por ejemplo, la imagen que hemos descargado de python también contiene <code>bash</code>, <code>pip</code> y otras muchas herramientas). Probemos a lanzar <code>bash</code>, para lo cual necesitamos que la sesión sea interactiva y tenga asociada una terminal, lo que se logra con las opciones <code>-i</code>, <code>-t</code>. Por tanto:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb24-1"><a href="#cb24-1"></a>$ <span class="ex">docker</span> run -i -t python:3.7 bash</span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="ex">root@0b0118936495</span>:/#</span></code></pre></div>
<p>El prompt que obtenemos nos muestra que somos el usuario <code>root</code> dentro del contenedor. Puedes intentar lanzar diferentes comandos. Se buscarán en el sistema de archivos del contenedor, no del anfitrión. De hecho estamos en una <em>sandbox</em> y no podemos acceder a los ficheros del anfitrión.</p>
<p>Intenta los siguientes comandos, mientras estás en el contenedor:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb25-1"><a href="#cb25-1"></a><span class="co"># python --version</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="ex">Python</span> 3.7.0</span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="co"># which python3</span></span>
<span id="cb25-4"><a href="#cb25-4"></a><span class="ex">/usr/local/bin/python</span></span>
<span id="cb25-5"><a href="#cb25-5"></a><span class="co"># rm /usr/local/bin/python</span></span>
<span id="cb25-6"><a href="#cb25-6"></a><span class="co"># python --version</span></span>
<span id="cb25-7"><a href="#cb25-7"></a><span class="ex">bash</span>: /usr/local/bin/python: No such file or directory</span>
<span id="cb25-8"><a href="#cb25-8"></a><span class="co"># exit</span></span></code></pre></div>
<p>¿Qué hemos hecho? Hemos visto que estábamos en el contenedor pues la versión de python era la 3.7. Hemos averiguado dónde estaba instalado python y ¡lo hemos borrado! Después, con <code>exit</code>, finalizamos el comando <code>bash</code> y ya que éste era el único proceso del contenedor, el contenedor muere.</p>
<p>No pasa nada, esos cambios se han hecho en la última capa del contenedor, la que se descarta y no tiene influencia en la imagen. Si lanzas el contenedor de nuevo verás que python vuelve a estar ahí (hazlo).</p>
<div class="Cuestion">
<p>Como consecuencia de los experimentos anteriores tendremos varios contenedores muertos, que puedes ver con <code>docker ps -a</code>. Puedes eliminarlos todos con:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb26-1"><a href="#cb26-1"></a>$ <span class="ex">docker</span> container prune</span></code></pre></div>
</div>
<h2 data-number="5.4" id="lanzar-el-servidor-udp-en-un-contenedor" data-number="5.4"><span class="header-section-number">5.4</span> Lanzar el servidor UDP en un contenedor</h2>
<p>Tras los ejemplos anteriores parece que para lanzar uno de los servidores UDP que hemos desarrollado en esta práctica, por ejemplo el <code>udp_servidor3_con_ok.py</code> bastaría colocarnos en la carpeta en la que está ese ejercicio y hacer como en el caso de <code>prueba.py</code>. En este caso, sin embargo, ya que el contenedor no terminará nunca pues es un servidor, interesará poner además la opción <code>-d</code> (de <em>daemon</em>), que causa que el contenedor completo se ejecute en <em>background</em> y desconectado de la terminal (no veremos lo que imprime el script):</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb27-1"><a href="#cb27-1"></a>$ <span class="ex">docker</span> run -d -v <span class="va">$(</span><span class="bu">pwd</span><span class="va">)</span>:/app python:3.7 python /app/udp_servidor3_con_ok.py</span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="ex">8e77ad5788d17341027ccab14f33af15df620442db6ae834971368c81544680e</span></span>
<span id="cb27-3"><a href="#cb27-3"></a>$ <span class="ex">docker</span> ps</span>
<span id="cb27-4"><a href="#cb27-4"></a><span class="ex">CONTAINER</span> ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS               NAMES</span>
<span id="cb27-5"><a href="#cb27-5"></a><span class="ex">8e77ad5788d1</span>        python:3.7          <span class="st">&quot;python /app/udp_s...&quot;</span>   About a minute ago   Up About a minute                       frosty_lumiere</span></code></pre></div>
<p>Vemos que esta vez está en ejecución (no hemos usado <code>-a</code> con <code>docker ps</code>). ¿Qué estará haciendo? Podemos conectarnos a un contenedor en ejecución, mediante el comando <code>exec</code> para ejecutar otro comando más dentro del mismo contenedor. Por ejemplo, ejecutemos <code>bash</code> en ese mismo contenedor. Será necesario las opciones <code>-i</code>, <code>-t</code> (que puede abreviarse a <code>-it</code>) para tener la sesión interactiva. Una vez dentro del contenedor podemos hacer <code>ps</code> (el comando linux) para ver qué está ejecutando:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb28-1"><a href="#cb28-1"></a>$ <span class="ex">docker</span> exec -it frosty_lumiere bash</span>
<span id="cb28-2"><a href="#cb28-2"></a><span class="ex">root@8e77ad5788d1</span>:/# ps aux</span>
<span id="cb28-3"><a href="#cb28-3"></a><span class="ex">USER</span>       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span>
<span id="cb28-4"><a href="#cb28-4"></a><span class="ex">root</span>         1  0.0  1.2  51128 12580 ?        Ss   15:32   0:00 python /app/udp_servidor3_con_ok.py</span>
<span id="cb28-5"><a href="#cb28-5"></a><span class="ex">root</span>         5  0.1  0.3  19956  3732 pts/0    Ss   15:38   0:00 bash</span>
<span id="cb28-6"><a href="#cb28-6"></a><span class="ex">root</span>        12  0.0  0.3  38388  3124 pts/0    R+   15:39   0:00 ps aux</span></code></pre></div>
<p>Vemos que tan sólo hay tres procesos dentro del contenedor. Y dos de ellos son los que acabamos de lanzar (el comando <code>bash</code> y dentro de él, <code>ps</code>).</p>
<p>Por tanto el sevidor está funcionando y estará esperando conexiones en el puerto 9999 (puerto por defecto). ¿Cómo conectar un cliente con él para comprobarlo? El problema es que el contenedor está en su propia sub-red privada y tiene su propia IP.</p>
<p>Podemos averiguar cuál es esa IP con el comando siguiente:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb29-1"><a href="#cb29-1"></a>$ <span class="ex">docker</span> inspect frosty_lumiere</span>
<span id="cb29-2"><a href="#cb29-2"></a><span class="bu">[</span> ... montones de información ... filtremos solo su IP ...]</span>
<span id="cb29-3"><a href="#cb29-3"></a>$ docker inspect frosty_lumiere|grep IPAddress</span>
<span id="cb29-4"><a href="#cb29-4"></a>            <span class="st">&quot;SecondaryIPAddresses&quot;</span>: null,</span>
<span id="cb29-5"><a href="#cb29-5"></a>            <span class="st">&quot;IPAddress&quot;</span>: <span class="st">&quot;172.17.0.2&quot;</span>,</span>
<span id="cb29-6"><a href="#cb29-6"></a>                    <span class="st">&quot;IPAddress&quot;</span>: <span class="st">&quot;172.17.0.2&quot;</span>,</span></code></pre></div>
<p>Una vez averiguado, probemos a conectar un cliente lanzado desde el anfitrión:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb30-1"><a href="#cb30-1"></a>$ <span class="ex">python3</span> udp_cliente4_reintenta.py 172.17.0.2 9999</span></code></pre></div>
<p>y debería funcionar. ¿Y si intentamos lanzar el cliente en otro contenedor? La sintaxis sería la siguiente:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb31-1"><a href="#cb31-1"></a>$ <span class="ex">docker</span> run -it -v <span class="va">$(</span><span class="bu">pwd</span><span class="va">)</span>:/app python:3.7 \</span>
<span id="cb31-2"><a href="#cb31-2"></a>   python /app/udp_cliente4_reintenta.py 172.17.0.2 9999</span></code></pre></div>
<p>¡Y vemos que también funciona!</p>
<h3 data-number="5.4.1" id="subredes-y-nombres" data-number="5.4.1"><span class="header-section-number">5.4.1</span> Subredes y nombres</h3>
<p>Lo que ocurre es que docker crea una sub-red privada en la que lanza por defecto todos los contenedores. Por tanto los contenedores pueden comunicarse unos con otros si conocen sus IPs. Además, en el nodo anfitrión ha creado una interfaz de red virtual que actúe como puente con la subred interna. Puedes verla si haces <code>ifconfig</code> (se llama <code>docker</code>), lo que explica por qué también desde el anfitrión pudimos comunicarnos con el servidor a través de su IP.</p>
<p>Sin embargo, desde fuera del anfitrión no sería posible comunicarse con este servidor. Por ejemplo, desde tu máquina Windows o desde la de tu compañero. Desde otras máquinas, la IP <code>172.17.0.2</code> no es accesible. Si quisieras que desde fuera se pudiera conectar con tu servidor, deberías “publicar” su puerto en otro puerto del anfitrión, con la opción <code>-P</code> de <code>docker run</code>. Más adelante usaremos esto también, pero de momento no hace falta.</p>
<p>Para terminar vamos a lanzar de nuevo cliente y servidor, pero esta vez dándoles unos nombres y dentro de una subred creada expresamente por nosotros, en lugar de usar la subred por defecto. Cuando hacemos esto, docker pone en marcha de forma transparente un servidor DNS de modo que ya no necesitamos conocer las IPs de los contenedores, sino que podemos referirnos a ellos por su nombre.</p>
<div class="Alumno">
<ol type="1">
<li><p>Primero asegúrate de que no tienes corriendo ningún contenedor con <code>docker ps</code>. Si aún está el servidor del apartado anterior puedes matarlo con <code>docker stop nombre_del_contenedor</code> (no confundas el nombre del contenedor con el de su imagen). Quizás tarde un poco. Docker envía la señal SIGTERM a los procesos dentro del contenedor para darles la opción de terminar de forma amistosa. Si lo ignoran (como es el caso), unos segundos más tarde los termina “por las malas” (SIGKILL).</p></li>
<li><p>Limpia los contenedores que hayan quedado detenidos con <code>docker container prune</code></p></li>
<li><p>Crea una nueva subred para lanzar contenedores en ella. Esto se logra con <code>docker network create</code>. Le daremos el nombre <code>pruebas</code>:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb32-1"><a href="#cb32-1"></a>$ <span class="ex">docker</span> network create pruebas</span></code></pre></div></li>
<li><p>Lanza el servidor dentro de esa subred, con el siguiente comando que a la vez le da un nombre (<code>servidor</code>) al contenedor:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb33-1"><a href="#cb33-1"></a><span class="ex">docker</span> run -d --name servidor --network pruebas\</span>
<span id="cb33-2"><a href="#cb33-2"></a>  -v <span class="va">$(</span><span class="bu">pwd</span><span class="va">)</span>:/app python:3.7 python /app/udp_servidor3_con_ok.py</span></code></pre></div></li>
</ol>
</div>
<p>Como consecuencia de haber creado una nueva subred, <code>ifconfig</code> en el anfitrión mostrará ahora una nueva interfaz virtual (en mi caso con la IP <code>172.18.0.1</code>, en tu caso puede cambiar), que serviria al anfitrión para conectar con los contenedores que haya dentro, por su IP.</p>
<p>Pero si lanzamos más contenedores dentro de esa misma subred, cada contenedor no necesita conocer las IPs de los restantes, pues puede acceder a ellos por sus nombres, que son los que hayamos dado en la opción <code>--name</code>.</p>
<p>Comprobémoslo. Para ello vamos a utilizar el comando <code>ping</code> que no está instalado por defecto en la imagen docker, por lo que hay que instalarlo el paquete <code>iputils-ping</code> antes de usarlo.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb34-1"><a href="#cb34-1"></a><span class="ex">docker</span> run -it --name test --network pruebas python:3.7 bash</span>
<span id="cb34-2"><a href="#cb34-2"></a><span class="ex">root@ea6f554d7422</span>:/# apt-get update</span>
<span id="cb34-3"><a href="#cb34-3"></a><span class="ex">root@ea6f554d7422</span>:/# apt-get install iputils-ping</span>
<span id="cb34-4"><a href="#cb34-4"></a><span class="ex">root@ea6f554d7422</span>:/# ping servidor</span>
<span id="cb34-5"><a href="#cb34-5"></a><span class="ex">PING</span> servidor (172.18.0.2) <span class="ex">56</span>(84) <span class="ex">bytes</span> of data.</span>
<span id="cb34-6"><a href="#cb34-6"></a><span class="ex">64</span> bytes from servidor.pruebas (172.18.0.2)<span class="bu">:</span> icmp_seq=1 ttl=64 time=0.053 ms</span></code></pre></div>
<p>Por tanto ahora podemos lanzar nuestro cliente así:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb35-1"><a href="#cb35-1"></a><span class="ex">docker</span> run -it --network pruebas --name cliente -v <span class="va">$(</span><span class="bu">pwd</span><span class="va">)</span>:/app python:3.7 \</span>
<span id="cb35-2"><a href="#cb35-2"></a>   python /app/udp_cliente4_reintenta.py servidor 9999</span></code></pre></div>
<div class="Cuestion">
<p>Prueba los comandos anteriores. Asegúrate de que entiendes todas las opciones y lo que está pasando. Pregunta a tu profesor si tienes alguna duda</p>
</div>
<h2 data-number="5.5" id="lanzar-el-ejemplo-broadcast" data-number="5.5"><span class="header-section-number">5.5</span> Lanzar el ejemplo broadcast</h2>
<div class="Alumno">
<p><strong>Ejercicio 7</strong></p>
<p>En la subred <code>pruebas</code> antes creada lanza tres contenedores que ejecuten <code>udp_servidor6_broadcast.py</code>. Dale un nombre diferente a cada uno, o no des nombre para que docker elija uno al azar (en este caso el nombre no importa porque el cliente no va a usarlo). Verifica que están todos en ejecución con <code>docker ps</code>.</p>
<p>Averigua la dirección de broadcast de esta subred, entrando en uno de esos contenedores y ejecutando <code>ip addr</code> (este comando no está instalado por defecto, por lo que debes instalar antes el paquete <code>iproute2</code> dentro del contenedor en marcha). Ahí podrás ver la IP de la interfaz, en su notación CIDR, por ejemplo <code>172.18.0.2/16</code> que indica que de la IP dada, los 16 primeros bits son la parte de red. Esto nos permite deducir la IP de broadcast.</p>
<p>Alternativamente esta información puede obtenerse desde fuera del contenedor y por tanto sin tener que instalar nada en él, ejecutando <code>docker inspect &lt;nombre_del_contenedor&gt;</code> y observando las variables <code>IPAddress</code> e <code>IPPrefixLen</code> que mostrarían en este caso <code>172.18.0.2</code> y <code>16</code> respectivamente. Compruébalo.</p>
<p>Lanza ahora el cliente <code>udp_cliente6_broadcast.py</code> usando como IP de broadcast la que has averiguado.</p>
<p>Comprueba que los tres servidores responden y que el cliente elige al primero de ellos para enviarle la petición. ¿Cuál es la IP del cliente? (mírala en la respuesta del servidor).</p>
<p>Guarda en dos ficheros los scripts shell necesarios para lanzar a todos los servidores (<code>udp_docker_lanzar_servidores.sh</code>) y el que lanza al cliente (<code>udp_docker_lanzar_cliente.sh</code>).</p>
</div>
</div>
</article>
</div>
</div>
</body>
</html>
